==========================================================
Gateway, Routing & Cross cutting concerns in Microservices
==========================================================

What are the challenges that we may face while we are trying to accept the external traffic into our microservices network?

-- we should have a single entry point into our microservice network; we should not allow different external clients talking with our microservices directly - instead we should have a single entry point into our microservices by using the products like API Gateway.

What are the challenges that we may face while we are trying to accept the external communication into our microservice?

Challenge # 

1) How do we maintain a single entry point into microservices network?
    --> here the question is - what is the problem if we don't maintain a single entry point; 
what if- I allow all the external clients to communicate directly with my microservices; there will be multiple drawbacks or challenges not maintaining a single entry point to our microservice network
  if we are not having a single entry point - then the external clients should maintain a track of all the microservices inside our microservice network, their endpoint URLs , port numbers, etc
 
   --> how do we build a single gatekeeper for all the inbound traffic to our microservices network. This way the client does not need to keep track of the different services involved in a transaction, simplifying the client's logic

2) How do we handle cross cutting concerns
     logging, auditing, tracing & security etc

3) How do we route based on custom requirements?
     how to provide dynamic routing capabilities which allows to define routing rules based on various criteria such as HTTP headers (version v1, v2), request parameters etc inside microservices network

Solution:
these challenges in microservices can be solved using - Edge Server / API Gateway / Gateway - this server will be sitting on the edge of the microservice network and monitoring all the incoming and outgoing requests 


----- Why we need a Edge Server or API Gateway inside microservices ------------

cross cutting concerns  -- non functional requirements

inside API Gateway -  we can perform many functionalities
-> Request Validation
-> Include & Exclude List - to perform some checks related to black listing or white listing of the IP address 
-> Authentication & Authorization
-> Rate Limit - we can limit the quantity of requests or the amount of requests coming from a particular client 
-> Dynamic Routing
-> Service Discovery
-> Modify Request & Response
-> Protocol Conversion

we can also handle negative scenarios like
-> implementing Exception Handling
-> implementing Circuit breaker to make our microservices fault-tolerant and resilient in nature

API gateway is also capable of sending all the Logging & monitoring related information - with tools like Grafana - using this we look for all the logs and errors or monitoring related information using beautiful dashboards

If we needed- we can also integrate API Gateway with Redis-cache - which means we can write some business logic by leveraging the cache that we can store inside this redis component

eureka sever is for service discovery and registration - which is entirely a different pattern. eureka server is not capable of performing all the non-functional requirements or implementing cross-cutting concerns

-----------------------------------------------------------
API Gateway Design Pattern:

This pattern acts as a single entry point for all client requests, routing them to the appropriate microservices. It can handle cross-cutting concerns like authentication, authorization, and rate limiting, simplifying client interactions and centralizing common functionalities.
-----------------------------------------------------------

An API Gateway also called an Edge Server, acts as an entry point for our microservices, so that external clients can access the services easily. It also helps us to handle cross-cutting concerns like Monitoring, Security, etc. In some instances, API Gateway also acts as Load Balancers.

- Acts as an entry point for the requests
- Forward the request to the downstream microservices using API Gateway
- Commonly used in the distributed systems and microservices architecture

Benefits of using API Gateway::
1. Handles cross-cutting concerns like
  --> Security
  --> Monitoring
  --> Rate Limiting

Drawbacks of using API Gateway 
--> Increases complexity as we have to maintain yet another component in our system landscape
--> Needs a lot of effort to maintain it as it will be a single point of failure - need to run multiple instances
--> Increased latency for the client requests

===========================
## Why to use API Gateway?
===========================
In our microservice project landscape, we have 3 services accessible to the user:

- Product Service
- Order Service
- Inventory service

For example, imagine that external clients like Web and Mobile applications consume these three independent services through the exposed endpoints. If the internal implementation of these services changes, then also the clients need to update the Endpoints on their side.

To workaround this issue, we use an API Gateway as the facade that provides an abstraction over the internal microservices.

## Spring Cloud Gateway MVC

**Spring Cloud Gateway MVC** is a library under the Spring Cloud project, that provides the API Gateway functionality. 

API Gateway acts as an abstraction over the microservices, and it forwards the request from the client to the relevant microservices.

To implement this feature, Spring Cloud Gateway uses the below building blocks:
Spring Cloud Gateway have 3 important parts::

1. Routes
2. Predicates
3. Filters

### Routes

A Route is the basic building block of the gateway, it can be defined using a uniqueId, a destination URI, and a collection of predicates and filters

- contains the URL to which request is to be forwarded to 

### Predicates

A Predicate is nothing but a criteria or a condition that you define to match against the incoming HTTP Request, for example, you can create a routing rule where you want to route the requests that have a specific Header and Request Parameter to Service A, then you can consider the headers and request parameters you want to match against the request as predicates.

In Spring Cloud Gateway, predicates are a core component of route definition, acting as conditions that determine whether an incoming HTTP request matches a particular route.


### Filters

Filters are components that allow you to modify the requests and responses before they are sent to the destination.

Filters in Spring Cloud Gateway are a fundamental component of its routing and request/response manipulation capabilities. They allow for the modification of HTTP requests before they are forwarded to a downstream service (pre-filters) and the modification of HTTP responses before they are sent back to the client (post-filters).


The routing rules defined above, for that we can follow 2 approaches
1) Using Java API
2) Using Property files

======================================================================
-> It acts as an entry point for all backend APIs
-> It acts as a mediator between frontend app and backend APIs
-> In API Gateway we will write filters and Routings
  Filter -> we can perform pre-process & post process
  Routings -> to forward a request to a particular backend API
======================================================================

---------- Spring Cloud Gateway --------------


Spring Reactor & Spring WebFlux ---> Spring Reactive Programming

spring.io > Projects > Spring Cloud > Spring Cloud Gateway


---------- Building Edge Server using Spring Cloud Gateway --------------

1. Create a New Spring Starter Project - gatewayserver
   Edge Server for CTS Bank microservices
   com.cognizant.gatewayserver

Dependencies: Reactive Gateway, Eureka Discovery Client (to connect to the eureka server and to fetch the service registry details of all the other microservices), Spring Boot Actuator, Spring Boot DevTools

-- application.yml ----  (from accounts ms and make corrections)

spring.application.name: gateway-server
server.port: 8072

management.endpoints.web.exposure.include: *
management.info.env.enabled: true

info.app.name: "gatewayserver"
info.app.description: "CTS Bank Gateway Server Application"
info.app.version: 1.0.0


management.endpoint.gateway.access: unrestricted

spring.cloud.gateway.server.webflux.discovery.locator.enabled: true   ---> we are telling to gateway server to connect with the discovery server (eureka) and locate all the details about the microservices - once it locates all the information about the individual microservices - we want the gateway server to use the same to forward the traffic from external client to the individual microservice 


spring.cloud.gateway.discovery.locator.enabled: true   ---> we are telling to gateway server to connect with the discovery server (eureka) and locate all the details about the microservices - once it locates all the information about the individual microservices - we want the gateway server to use the same to forward the traffic from external client to the individual microservice 


----> Edge Server with default routing configs <-------

=====>  run eureka server, all microservices and then only gateway server

http://localhost:8761/ ---> eureka server dashboard

http://localhost:8072/actuator

http://localhost:8072/actuator/gateway

http://localhost:8072/actuator/gateway/routes

postman
POST   http://localhost:8072/ACCOUNTS/api/create

ACCOUNTS ---> name of ms in eureka server
api/create ---> actual path

GET http://localhost:8072/ACCOUNTS/api/fetch?mobileNumber= xxxxx

same way access loans and cards

http://localhost:8072/LOANS/api/create?mobileNumber=9848586878


---- make changes in application.properties/application.yml inside Gateway server to accept service names with lower case ----

	spring.cloud.gateway.discovery.locator.lower-case-service-id: true    ---- previous versions
	spring.cloud.gateway.server.webflux.discovery.locator.lower-case-service-id: true

POST   http://localhost:8072/accounts/api/create





======= PART 2 ==============

------ Implementing Custom Routing using Spring Cloud Gateway ------

custom requirement --> suppose we want to make the clients to send a request to 
  http://localhost:8072/ctsbank/accounts/api/create   
  http://localhost:8072/ctsbank/loans/api/create?mobileNumber=9848586878 
  http://localhost:8072/ctsbank/cards/api/create?mobileNumber=9848586878 

--- like dynamic routing --- define our-own routing configurations -- not the default routing configurations


in bootstrap class

	@Bean
	public RouteLocator customRoutings(RouteLocatorBuilder routeLocatorBuilder) {
	 return routeLocatorBuilder.routes()
				.route(path_route -> path_route
					     .path("/ctsbank/accounts/**")
					     .filters(f -> f.rewritePath("/ctsbank/accounts/(?<segment>.*)","/${segment}"))
					.uri("lb://ACCOUNTS")) 

				.route(p -> p
					     .path("/ctsbank/loans/**")
					     .filters( f -> f.rewritePath("/ctsbank/loans/(?<segment>.*)","/${segment}"))
					.uri("lb://LOANS")) 

				.route(p -> p
					     .path("/ctsbank/cards/**")
					     .filters( f -> f.rewritePath("/ctsbank/cards/(?<segment>.*)","/${segment}"))
					.uri("lb://CARDS")) 
		.build();			
	}	
}



run the application 

http://localhost:8072/ctsbank/accounts/api/create   

---> check  http://localhost:8072/actuator/gateway/routes

-- we can see the default configurations also - to disable the default behaviour
spring.cloud.gateway.discovery.locator.enabled: false
spring.cloud.gateway.server.webflux.discovery.locator.enabled: false

---> check  http://localhost:8072/actuator/gateway/routes


============== PART - 3 =================


--- addResponeHeader filter -----------------

refer in official documentation
spring.io > Projects > Spring Cloud > Spring Cloud Gateway > Learn
 --> Fluent Java Routes API
 --> Route Predicate Factories  - The path Route Predicate Factory

 --> GatewayFilter Factories  - The AddResponseHeader GatewayFilter Factory

			.route(p -> p
			    .path("/ctsbank/accounts/**")
			    .filters( f -> f.rewritePath("/ctsbank/accounts/(?<segment>.*)","/${segment}")
					.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
				.uri("lb://ACCOUNTS")) 


add the responseHeader filter for the rest route also

run the application
http://localhost:8072/ctsbank/accounts/api/create   
  check the Response Headers in POSTMAN

==================================================================================================

Route configurations using application.yml

Approach -2 in application.yml

spring:
  application:
    name: GATEWAY-SERVICE
  cloud:
    gateway:
      routes:
      - id: order-service
        uri: lb://ORDER-SERVICE      #lb â€“ load balancer
        predicates:			#URL Patterns
          - path=/order/**
      - id: payment-service
        uri: lb://PAYMENT-SERVICE
        predicates:
          - path=/payment/**    



Route configurations using application.properties

API Gate Way routing Configuration
server.port=9090
eureka.client.serviceUrl.defaultZone = http://localhost:8083/eureka
spring.application.name=Api-Gateway
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

spring.cloud.gateway.routes[0].id=service1
spring.cloud.gateway.routes[0].uri=lb://MICROSERVICE1
spring.cloud.gateway.routes[0].predicates[0]=Path=/service1/**


===========================================  END =================================================

========================================
Working with Spring Cloud API Gateway
========================================

1) Create Spring boot application with below dependencies

		-> eureka-client
		-> cloud-reactive-gateway
		-> devtools

2) Configure API Gateway Routings in application.yml file like below

spring:
  application:
    name: API-Gateway
  cloud:
    gateway:
      routes:
      - id: api-1
        uri: lb://WELCOME-SERVICE
        predicates: 
          - Path=/welcome
      - id: api-2
        uri: lb://GREET-SERVICE
        predicates: 
          - Path=/greet
server:
  port: 3333

4) Create Filter to validate incoming request

		if request contains below header then it is valid request so process it.

			Secret=sunil@123

		if above header is not present then it is invalid request, don't process it.					


@Component
public class MyFilter implements GlobalFilter {

	@Override
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

		System.out.println(" filter() - executed..... ");

		// validate request
		
		ServerHttpRequest request = exchange.getRequest();
		HttpHeaders headers = request.getHeaders();
		Set<String> keySet = headers.keySet();
		
		if(!keySet.contains("Secret")) {
			throw new RuntimeException("Invalid Request");
		}
		
		List<String> list = headers.get("Secret");
		if(!list.get(0).equals("sunil@123")) {
			throw new RuntimeException("Invalid Request");
		}
		
		return chain.filter(exchange);
	}
}



