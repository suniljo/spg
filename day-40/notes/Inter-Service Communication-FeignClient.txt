=======================================================
Feign Client code changes to invoke other microservices
=======================================================

Feign Client ---> Declarative REST Client. 

OpenFeign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations.


TASK: create a new REST API inside the accounts microservice to accumulate account related information, loans related information and cards related information based upon a given mobile number and it should consolidate all the responses from the other microservices like loans & cards along with the account related data. 

At present account microservice is not having any information about cards and loans - so it has to connect with the cards & loans microservice to get the data 

To establish the internal connection between the microservices - we need to use Open Feign Client library or even we can use RestTemplate , WebClient

refer: RestTemplate Vs FeignClient Vs WebClient

Feign Client in Spring Boot, also known as Spring Cloud OpenFeign, is a declarative REST client that simplifies inter-service communication in microservice architectures.


== PRACTICALS ====

--accounts microservice ---

1. new dependency: OpenFeign (spring-cloud-starter-openfeign)

2. on bootstrap class  - @EnableFeignClients  --> enables Feign client related functionalities inside our accounts microservice - so that, accounts microservice can connect with other microservices - Scans for interfaces that declare they are feign clients  - @FeignClient

3. in-order to connect with Loans & cards microservices in a traditional approach - we can use RestTemplate , WebClient and we pass the URL, request data, port number etc with the RestTemplate or WebClient 

when we use the OpenFeign client - we don't need to write the implementation code - we just have to write the declarative code (something like the approach that we used in Data JPA - not writing any implementation code - only declarative code)

4. copy the CardsDto and LoansDto from the respective microservices and place it in accounts microservice "dto" package

5. create client interface  - to help the accounts microservice to connect with the cards microservice

package com.cognizant.accounts.service.client;

@FeignClient("cards")  --> to use the openfeign libraries - name used to register cards microservice with eureka server
public interface CardsFeignClient {

    @GetMapping(value = "/api/fetch", consumes = "application/json")
    public ResponseEntity<CardsDto> fetchCardDetails(@RequestParam String mobileNumber); //should match with the cards microservice
}


-- behind the scenes - our CardsFeignClient will connect to the Eureka Server and try to fetch all the instances that are registered with the logical name "cards" - once it gets the instance information - it will cache those details for 30 seconds which is the default period and within 30 seconds it is not going to connect again with eureka server; instead it is going to leverage the details present in the cache. 

Based upon the IP details in the cache - it is going to invoke the api "/api/fetch" along with mobileNumber of Cards microservice 

---- all the implementation codes will be generated by OpenFeign client

---- create a similar feign client for loans microservice


------------------- LoansFeignClient.java ------------------

package com.cognizant.accounts.service.client;

@FeignClient("loans")
public interface LoansFeignClient {
    @GetMapping(value = "/api/fetch",consumes = "application/json")
    public ResponseEntity<LoansDto> fetchLoanDetails(@RequestParam String mobileNumber);
}



6. create a new DTO class for sending response of account , customer, loans and cards details - CustomerDetailsDto - to hold all details

-------------- CustomerDetailsDto.java -----------------

package com.cognizant.accounts.dto;

@Data
public class CustomerDetailsDto {		---> take the details from CustomerDto
 private String name;
 private String email;
 private String mobileNumber;
 private AccountsDto accountsDto;

 private CardsDto cardsDto;
 private LoansDto loansDto;
}


7. create a new Controller -- CustomerDetailsController

package com.cognizant.accounts.controllers

@RestController
@RequestMapping(path="/api", produces = {MediaType.APPLICATION_JSON_VALUE})
@Validated
public class CustomerDetailsController {
    @GetMapping("/fetchCustomerDetails")
    public ResponseEntity<CustomerDetailsDto> fetchCustomerDetails(@RequestParam @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits") String mobileNumber){
      return null;
    }
}


8. create an interface in service package

package com.cognizant.accounts.service;	
public interface ICustomerService {
    CustomerDetailsDto fetchCustomerDetails(String mobileNumber);
}


9. implementation class

@Service
@AllArgsConstructor
public class CustomerServiceImpl implements ICustomerService {

    private AccountsRepository accountsRepository;
    private CustomerRepository customerRepository;

    private CardsFeignClient cardsFeignClient;
    private LoansFeignClient loansFeignClient;

    @Override
    public CustomerDetailsDto fetchCustomerDetails(String mobileNumber) {   //refer AccountsServiceImpl
        Customer customer = customerRepository.findByMobileNumber(mobileNumber).orElseThrow(
                () -> new ResourceNotFoundException("Customer", "mobileNumber", mobileNumber)
        );
        Accounts accounts = accountsRepository.findByCustomerId(customer.getCustomerId()).orElseThrow(
                () -> new ResourceNotFoundException("Account", "customerId", customer.getCustomerId().toString())
        );

        CustomerDetailsDto customerDetailsDto = CustomerMapper.mapToCustomerDetailsDto(customer, new CustomerDetailsDto());
        customerDetailsDto.setAccountsDto(AccountsMapper.mapToAccountsDto(accounts, new AccountsDto()));

        ResponseEntity<LoansDto> loansDtoResponseEntity = loansFeignClient.fetchLoanDetails(mobileNumber);
        customerDetailsDto.setLoansDto(loansDtoResponseEntity.getBody());

        ResponseEntity<CardsDto> cardsDtoResponseEntity = cardsFeignClient.fetchCardDetails(mobileNumber);
        customerDetailsDto.setCardsDto(cardsDtoResponseEntity.getBody());

        return customerDetailsDto;
    }
}

--- inside CustomerMapper class
    public static CustomerDetailsDto mapToCustomerDetailsDto(Customer customer, CustomerDetailsDto customerDetailsDto) {
        customerDetailsDto.setName(customer.getName());
        customerDetailsDto.setEmail(customer.getEmail());
        customerDetailsDto.setMobileNumber(customer.getMobileNumber());
        return customerDetailsDto;
    }



-- in Controller class
package com.cognizant.accounts.controllers

@RestController
@RequestMapping(path="/api", produces = {MediaType.APPLICATION_JSON_VALUE})
@Validated
public class CustomerController {
    private final ICustomersService iCustomersService;
   
    public CustomerController(ICustomersService iCustomersService){
        this.iCustomersService = iCustomersService;
    }

    @GetMapping("/fetchCustomerDetails")
    public ResponseEntity<CustomerDetailsDto> fetchCustomerDetails(@RequestParam
                                                                   @Pattern(regexp="(^$|[0-9]{10})",message = "Mobile number must be 10 digits") String mobileNumber){
      CustomerDetailsDto customerDetailsDto = iCustomersService.fetchCustomerDetails(mobileNumber);
      return ResponseEntity.status(HttpStatus.OK).body(customerDetailsDto);
    }
}


start eureka server, accounts, cards & loans ms

check in eureka dashboard  -- http://localhost:8761

POST - http://localhost:8080/api/create
POST - http://localhost:9000/api/create?mobileNumber=xxxx    use the same mobile number
POST - http://localhost:8090/api/create?mobileNumber=xxxx    use the same mobile number

GET - http://localhost:8080/api/fetchCustomerDetails?mobileNumber=xxxx    

we have used the logic name of microservice - not IP address to invoke the other ms 
it will go and check in the service registry agent (eureka) - and will get the complete details of the "cards" / "loans" ms



@FeignClient(name="loans-service", url = "http://localhost:8090")



---------------- Eureka Self-Preservation mode to avoid Traps in Network Issues ----------------------------

In a normal working microservice network - eureka server will expect heartbeat from the microservice instances which are registered with it; for some reason if eureka server does not receive heartbeat from a particular microservice instance within a certain time frame then it assumes that the instance has become un-responsive, or crashed or it became unhealthy - so based upon this assumption - eureka server is going to delete the details of that particular instance from the service registry details; so that it cannot be discovered by the other microservices. 

It helps eureka server to maintain an up-to-date view of the registered service instances 

sometimes network issue may happen - network may not work for few seconds or minutes 


CONSUL is an alternative to EUREKA


Why 8761 port is given to Eureka Server?

=> If "Server-Registry" project port is 8761 then clients can discover service-registry and will register automatically with service-registry. 

=> If service registry project running on any other port number then we have to register clients with service-registry manually