=====================================================
Securing Spring Boot Application with Spring Security
=====================================================

-> Spring Boot is a mandatory requirement for every Java Developer

Common Interview Questions on Spring Boot

-> Security	- How did you implement security to your web application so that there won't be any security breaches in your application?

-> Password	- How are you storing passwords in your application?  Users normally pass the email id and password.  
How to store passwords, validate them, encode, decode them using Industry standard encryption algorithms

Do you think that the password like "admin@123" will be stored as it is in the DB?
We need to perform some operations before storing the password in the DB

-> Users and Roles	- How to maintain the user level security based on their roles and grants associated with them?

Can every user access every page/functionality of your application or based on the roles the users will access the functionality - based on the roles

How can we perform role based security?

-> Multiple Logins	- How can I implement a mechanism where the user will login once only and start using my application?	With FB credentials we can login to FB from multiple devices	Gmail Credentials, Amazon Prime etc

-> Fine Grained Security - How can I implement security at each level of my application using authorization rule?

-> CSRF & CORS
CSRF - Cross-Site Request Forgery      
CORS – Cross Origin Resource Sharing is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources

What is CSRF attacks and CORS restrictions? How to overcome them?

-> JWT & OAuth2	
What is JWT and OAuth2? How can I protect my application using them?

-> Preventing Attacks	- How to prevent security attacks like Brute force, Stealing of Data, session fixation

A brute force attack is a hacking method that uses trial and error to crack passwords, login credentials, and encryption keys. It is a simple yet reliable tactic for gaining unauthorized access to individual accounts and organizations' systems and networks.

Every developer should know the security techniques that we need to implement in our application


What is Security?
----------------
Security is for protecting your data and business logic inside our application
Our company data - employee details, projects details

ECommerce Site - Product Details, Reseller Details, Customer Details, Order Details etc

Security is a Non Functional Requirement - No client will specifically asks that he need security

Security from Development Phase - Security should be considered from development phase itself along with business logic (not at the last)

Different Types of Security - Security for an application will be implemented in different ways like using firewalls, HTTPS, SSL, Authentication, Authorization etc

Authentication Vs Authorization
-------------------------------
Basic thing of Security is Authentication & Authorization

Authentication -> Verifies who you are: college student, company employee
Authorization -> decides whether you have permission to access a resource:
User XYZ can only read data	 
User ABC can read and update data

#1 in authentication - the identity of users are checked for providing the access to the system (implementing login functionality).  in authorization - user's authorities are checked for accessing the resources

#2 authentication done before authorization           		
   authorization always happens after authentication

#3 authentication usually needs user's login details     	
   authorization needs user's privileges or roles

#4 if authentication fails usually we will get 401 (Unauthorized) error response
   if authorization fails usually we will get 403 (Forbidden) error response

for example - as a bank employee/ customer - in order to perform actions in the application we need to prove our identity
in authorization - once logged into the application - my roles, authorities will decide what kind of actions I can do

as an example - you want to travel in a flight - your Passport or Voter ID card is the Authentication and your ticket is authorization


=== How does Spring MVC Work? ===

DispatcherServlet acts as the front controller
  -> Intercepts all requests
  -> Routes to the Right Controller

   Request ---> DispatcherServlet ----> Controller(s)


=== How does Spring Security Work? ====

Spring security intercepts all requests
Spring security executes a series of filters - also called Spring Security Filter Chain
   Request ---> Spring Security ---> DispatcherServlet ----> Controller(s)
  

Filters provide these features:
    - Authentication: Is it a valid user? (Ex: BasicAuthenticationFilter)
    - Authorization: Does the user have right access?(Ex: AuthorizationFilter)

   Other Features:
    - Cross-Origin Resource Sharing (CORS) - CorsFilter
        Should you allow AJAX calls from other domains?
        Ex: if you are building a fullstack application, you have the frontend deployed to one domain like React and the backend rest api deployed to another domain. the backend REST API should allow calls from the frontend  application which is running in the browser - this can be configured usingCORS

    - Cross Site Request Forgery (CSRF) - CsrfFilter
       - typically a user session is created for you once you login to a site/web application, and a user session is typically identified by using a cookie in the browser, if you don't logout from that site and you go to a malicious web site - this site can make use of the previous authentication that you have - the cookie which is present in the browser. this vulnerability is known as CSRF. when we add spring security - CSRF is automatically enabled for any update/ delete requests

	A malicious website making use of previous authentication on your website
	Default: CSRF protection enabled for update requests - POST, PUT etc..

Spring security provides a default Login Page, Logout Page
	LogoutFilter, DefaultLoginPageGeneratingFilter, DefaultLogoutPageGeneratingFilter
     Translating exceptions into proper Http Responses (ExceptionTranslationFilter)

Order of filters is important (typical order is)
  1: Basic Check Filters - CORS, CSRF, ..
  2: Authentication Filters - do they have the correct credentials
  3: Authorization Filters - do they have the right access to perform the right action on the right resource


------- Practicals -----

01.sb-security-app

   WelcomeRestController
add spring security dependency	- User Name: user    Password from console

In Browser - Inspect > Network > All - /welcome?contine - Headers

- Used by most web applications
- Uses a Session Cookie    JSESSIONID: E2E693A57F6F7E4AC112A1BF4D40890A
- Spring security enables form based authentication by default
- Provides a default Login Page
- Provides a default Logout Page
- Provides a /logout URL  - http://localhost:8080/logout


To provide our own username and password - in application.properties
spring.security.user.name = sunil
spring.security.user.password = sunil@123


How does basic authentication work?

 Base 64 encoded username:password is sent as request header
  Authorization (header): Basic dXNlcjo1YmIzYmIxNi0yNTEwLTQxZjctYjEyNy0zZjU5NjgxM2NkOTg=

 DISADVANTAGE of Basic Authentication-> Easy Decoding
 -> Basic Auth Authorization Header:
     Does NOT contain authorization information (user access, roles,..)
     Does NOT have Expiry Date


CSRF - Cross Site Request Forgery
=================================

-> you are logged-in to your bank's online platform; which creates a cookie and will be saved in your browser
-> you open a malicious website without logging out from the bank's application
-> other website may execute a bank transfer on your bank account without your knowledge using the cookie of bank in your system's browser
-- this is called as CSRF


How can you protect from CSRF?
1) Synchronizer Token Pattern
   - create a new token for each & every request
   - spring security enables this by default
   - to make any updates (POST, PUT, DELETE...), you need a CSRF token from the previous request


02.sb-security-csrf-app

record Product(Integer productId, String productName) {}

@RestController
public class ProductController {
 private Logger logger = LoggerFactory.getLogger(getClass());
 
 private static final List<Product> productsList = List.of(new Product(101, "Mobile"),
		 new Product(102, "Computer"), new Product(103, "Laptop") );
 
 @GetMapping("/products")
 public List<Product> getAllProducts(){  return productsList; }
 
 @GetMapping("/products/{pid}")
 public Product getProductByProductId(@PathVariable Integer pid) {
   Product product = productsList.stream().filter(prod -> prod.productId().equals(pid)).findFirst().orElse(null);
   return product; 
  }

  @PostMapping("/products/new")
  public void addNewProduct(@RequestBody Product product) {
   productsList.add(product);
   logger.info("saving new product {}", product);
 }
}


Authorization : Basic encoded username:password
GET http://localhost:8080/products - no issue
GET http://localhost:8080/products/101 - no issue
POST http://localhost:8080/products/new - failing error 401


CSRF for REST API

- by default Spring security creates a csrf token for all form based application
- to try - run previous app http://localhost:8080/welcome
   http://localhost:8080/logout   - view page source
   -- delete csrf field and submit and see the error - (Inspect page)
   -- try again /logout without deleting csrf node

- create a new controller
@RestController
public class CSRFRestController {
 @GetMapping("/csrf-token")
 public CsrfToken retrieveCsrfToken(HttpServletRequest request) {
   return (CsrfToken) request.getAttribute("_csrf");
 }
}
   
http://localhost:8080/csrf-token	 -- get the token

POST http://localhost:8080/products/new
New Header: X-CSRF-TOKEN  <csrf_token_value>			--- it works ----

 2: SameSite cookie (Set-Cookie: SameSite=Strict)  - another approach
  -- this cookie will be sent only to that specific site, it will not be send to any other site. to enable it, in  application.properties   (from Spring Boot 2.6_     server.servlet.session.cookie.same-site=strict  

   Depends on browser support

###---- Creating Spring Security Configuration to disable CSRF ----####

- SpringBootWebSecurityConfiguration (Spring Boot 2.x) class contains the default web security configuration
- WebSecurityConfiguration for Spring Boot 3.x



check in console for logs of "CSRF"

-- create a new SecurityConfigurations class

package com.wipro.boot.security.configs;

@Configuration
public class SecurityConfigurations {
 
 @Bean
 public SecurityFilterChain customSecurityConfigurations(HttpSecurity http) throws Exception {
   //--- default configuration ----
   httpSecurity.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated());

   http.csrf(csrf ->csrf.disable());
   //http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
   http.httpBasic(Customizer.withDefaults()); //--configures HTTP Basic authentication.

   DefaultSecurityFilterChain filterChain = http.build();

   return filterChain; 
 }
}  

run the application - search for csrf in logs       **run post request without csrf header - and it works


2) Same-Site Cookie (SameSite-Strict=Strict)
in application.properties
 server.servlet.session.cookie.same-site=strict


default web security configuration details are available with 
 - SpringBootWebSecurityConfiguration / WebSecurityConfigurerAdapter (SB 2.x)
 - WebSecurityConfiguration (SB 3.2)


Working with CORS
-----------------
- Cross Origin Resource Sharing
- browsers do not allow AJAX calls to resources outside current origin
- let us imagine, that we have a full-stack application, and your frontend (a React/Angular/Vue application) is making a REST API call to a different domain (a different URL), typically our browser will not allow that kind of calls

- Cross-Origin Resource Sharing (CORS) is a specification that allows you to configure which cross-domain requests are allowed

- there are 2 approaches that we can follow
 (1) Global Configuration  - applicable to all rest controllers/resources 
   Configure addCorsMappings callback method in WebMvcConfigurer      (BasicSecurityConfiguration.java)
/*--- global configuration for CORS ----*/
@Bean
public WebMvcConfigurer corsConfigurer() {
  return new WebMvcConfigurer() {
    public void addCorsMappings(CorsRegistry registry) {
      registry.addMapping("/**")
              .allowedMethods("*")
              .allowedOrigins("http://localhost:3000");
  } };
}


(2) Local Configuration
  @CrossOrigin - Allow from all origins
  @CrossOrigin(origins = "https://localhost:3000") - Allow from specific origin


=========================
Storing User Credentials
=========================

1) Default Credentials - which are generated by Spring Security - user name = user   password = <from logs>

2) We can configure credentials in application.properties file
   spring.security.user.name = sunil
   spring.security.user.password = sunil@123

3) We can configure user credentials with In-Memory of our application (In-Memory Credentials)

4) We can configure user credentials in Database (JDBC Authentication)

5) We can configure user credentials in LDAP Server (LDAP Authentication) - Lightweight Directory Access Protocol    
Open protocol for directory services and authentication

03.sb-security-in-memory-auth

	//--- to configure multiple in-memory users  
	//UserDetailsService --> Core interface which loads user-specific data. 
	@Bean
	public UserDetailsService generateUsers() {
		UserDetails user1 = User.withUsername("admin")
					.password("{noop}12345")
					.roles("ADMIN")
					.build();
		
		var user2 =User.withUsername("sunil")
				.password("{noop}password123#")
				.roles("MANAGER")		//Create an ENUM for user roles
				.build();
		
		/*
		UserDetailsManager userDtlsMgr = new InMemoryUserDetailsManager();
		userDtlsMgr.createUser(user1);
		userDtlsMgr.createUser(user2);		
		return userDtlsMgr;
		*/
		
		UserDetailsService userDtlsService = new InMemoryUserDetailsManager(user1, user2);
		
		return userDtlsService;
	}

==================================================
Storing user credentials using JDBC  - H2 Database
==================================================
				
04.sb-security-jdbc-auth
dependencies – Spring Web, Security, Spring Data JDBC (spring-boot-starter-jdbc), H2 driver

spring.h2.console.enabled=true	spring.datasource.url=jdbc:h2:mem:userDB		chrome://restart

http://localhost:8080/h2-console  - provide credentials - h2-console uses frames (view source) and spring security disables frames by default -  to enable it		in filterChain() method 
 http.csrf().disable();
 /*httpSecurity.csrf().ignoringAntMatchers("/h2-console/**");*/
 http.headers().frameOptions().sameOrigin();
open the source of org.springframework.security.core.userdetails.jdbc."JdbcDAOImpl" class and see the DEFAULT_USER_SCHEMA_DDL_LOCATION

add a new method in BasicSecurityConfiguration class
@Bean
public DataSource dataSource() {
 return new EmbeddedDatabaseBuilder()
		.setType(EmbeddedDatabaseType.H2)
		.addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
		.build();
}

run the application - http://localhost:8080/h2-console



==============================================================
$$$---- Working with JdbcUserDetails - MySQL Database ---- ###
==================================================------------
mysql> create database db_cognizant;
mysql> use db_cognizan;
mysql> create table users(username varchar(50), password varchar(200), enabled int);
mysql> create table authorities(username varchar(100), authority varchar(100));


  @Autowired
  private DataSource dataSource;

  @Autowired
  private BCryptPasswordEncoder encoder;


	@Bean
	public UserDetailsService generateUsers() {
		UserDetails user1 = User.withUsername("admin")
					//.password(encoder.encode("12345"))
					.password("12345")
					.passwordEncoder(pwd -> encoder.encode(pwd))
					.roles("ADMIN", "MANAGER")
					.build();
		
		var user2 =User.withUsername("sunil")	
				//.password(encoder.encode("password123#"))
				.password("password123#")
				.passwordEncoder(pwd -> encoder.encode(pwd))				
				.roles("MANAGER")
				.build();
		
		UserDetailsManager userDtlsMgr = new JdbcUserDetailsManager(dataSource);
		userDtlsMgr.createUser(user1);
		userDtlsMgr.createUser(user2);	
		
		return userDtlsMgr;
	} 

--- using PasswordEncoder ----
@Configuration
public class AppConfig {
	
	@Bean
	public BCryptPasswordEncoder getPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}
}


---------SecurityConfiguration.java -----

 @Configuration
public class SecurityConfiguration {
  @Autowired
  private DataSource dataSource;
  
  @Autowired
  private BCryptPasswordEncoder encoder;
  
  @Bean
  public SecurityFilterChain securityFilter(HttpSecurity http) throws Exception {
	  
	  http.authorizeHttpRequests(request -> request.anyRequest().authenticated());
	  
	  http.csrf(csrf -> csrf.disable());
	  
	  http.httpBasic(Customizer.withDefaults()); //Configures HTTP Basic authentication. 
	  
	  DefaultSecurityFilterChain filterChain = http.build();
	  
	  return filterChain;
  }
  
 
	@Bean
	public UserDetailsService generateUsers() {
		UserDetails user1 = User.withUsername("admin")
					//.password(encoder.encode("12345"))
					.password("12345")
					.passwordEncoder(pwd -> encoder.encode(pwd))
					.roles("ADMIN", "MANAGER")
					build();
		
		var user2 =User.withUsername("sunil")	
				//.password(encoder.encode("password123#"))
				.password("password123#")
				.passwordEncoder(pwd -> encoder.encode(pwd))				
				.roles("MANAGER")
				.build();
		
		UserDetailsManager userDtlsMgr = new JdbcUserDetailsManager(dataSource);
		userDtlsMgr.createUser(user1);
		userDtlsMgr.createUser(user2);	
		
		return userDtlsMgr;
	} 
}


Storing BCrypt Encoded Passwords

- PasswordEncoder - interface for performing one way transformation of a password



05.sb-security-auth

--------- BankRestController.java ----------
@RestController
public class BankRestController {
	
	@GetMapping("/home")
	public String homePage() {
		return "Welcome to State Bank of India";
	}
	
	@GetMapping("/balance")
	public String balancePage() {
		return "This page shows Customer's Account Balance";
	}	
	
	@GetMapping("/statement")
	public String statementsPage() {
		return "This page shows Customer's Monthly Statement";
	}	
	
	@GetMapping("/loans")
	public String loansPage() {
		return "This page shows Customer's Loan A/cs Details";
	}	
	
	@GetMapping("/contact")
	public String contactPage() {
		return "Contact SBI's Customer Care using No: xxxxxxxxxxx";
	}
}

----- application.properties -------
spring.security.user.name = sunil
spring.security.user.password = sunil@123

-- now to access any functionality we need to do login




Project Requirement

-- in a real-time scenario -do you think to secure all the methods in the application or only some methods to be secured? -- we need to secure only important methods

/home -- no need to secure; any one should be able to access
/balance -- this endpoint should be secured
/statement -- this endpoint should be secured
/loan -- this endpoint should be secured
/care - no need to secure -- open to everyone

--> here out of 5 functionality - we need to secure 3 methods (endpoints)   
how to customize the security? customize the requirement for  (above)


@Configuration
public class SecurityConfiguration {
  
	@Bean
	public SecurityFilterChain customSecurityConfigurations(HttpSecurity httpSecurity) throws Exception {
		httpSecurity.authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers("/home","/contact")
									 .permitAll()														 .anyRequest()
									 .authenticated());
		
		httpSecurity.csrf(csrf -> csrf.disable());
		
		httpSecurity.httpBasic(Customizer.withDefaults()); 
		
		SecurityFilterChain filterChain = httpSecurity.build();
		
		return filterChain;
	}
}




05.sb-security-authorization

@RestController
public class BankRestController {
	@GetMapping("/home")
	public String homePage() {		return "Welcome to State Bank of India";	}	

	@GetMapping("/admin")
	public String adminPage() {		return "This page is for Administrators";	}
	
	@GetMapping("/manager")
	public String managerPage() {		return "This page is for Managers";	}	
	
	@GetMapping("/clerk")
	public String clerkPage() {		return "This page is for Clerks";	}
	
	@GetMapping("/cashier")
	public String cashierPage() {		return "This page is for Cashiers";	}	
	
	@GetMapping("/customer")
	public String customerPage() {		return "This page is for Customers";	}	
	
	@GetMapping("/care")
	public String customerCarePage() {		return "Contact State Bank of India";	}
}


	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		return http.authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers("/home","/contact")
															.permitAll()
															.requestMatchers("/admin").hasRole("ADMIN")
															//.requestMatchers("/admin/**").hasRole("ADMIN")
															.requestMatchers("/manager").hasAnyRole("ADMIN","MANAGER")
															//.requestMatchers("/manager").hasAnyAuthority("ADMIN","MANAGER")
															.requestMatchers("/clerk").hasAnyRole("ADMIN","MANAGER","CLERK")
															.anyRequest()
															.authenticated())
					.csrf(csrf -> csrf.disable())
					.httpBasic(Customizer.withDefaults())
					.build();
	}



---- AppConfig.java-----
@Configuration
public class AppConfig {
	@Bean
	public PasswordEncoder getPasswordEncoder() {
		PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
		return encoder;
	}
}

============= Implementation using HashMap =============
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        Map<String, String[]> authorizationRules = new HashMap<>();
        authorizationRules.put("/admin/**", new String[]{"ADMIN"});
        authorizationRules.put("/user/**", new String[]{"USER", "ADMIN"});
        authorizationRules.put("/public/**", new String[]{}); // No specific role required

        http.authorizeHttpRequests(authz -> {
                authorizationRules.forEach((pattern, roles) -> {
                    if (roles.length > 0) {
                        authz.requestMatchers(pattern).hasAnyRole(roles);
                    } else {
                        authz.requestMatchers(pattern).permitAll(); // Public access
                    }
                });
                authz.anyRequest().authenticated(); // All other requests require authentication
            })
            .formLogin(form -> form.permitAll()) // Example: Enable form login
            .logout(logout -> logout.permitAll()); // Example: Enable logout

        return http.build();
    }
}

======================================================================



====== OAuth2 ===========
Open Authorization  -- Quora

OAuth2 is a widely-used protocol for authorization that enables applications to securely access resources on behalf of users. When combined with Spring Boot, OAuth2 facilitates authentication and authorization for both REST APIs and web applications.

OAuth2 is an authorization framework that allows third-party applications to gain limited access to an HTTP service on behalf of a user. It can also handle authentication by delegating it to a third-party service, known as the Authorization Server.

OAuth2 is a standard designed to allow a website or application to access resources hosted by other web applications on behalf of a user. 

OAuth is an industry standard for Authentication and Authorization

OAuth 2.0 is an open standard protocol that allows users to grant third-party applications limited access to their resources on a different service, without sharing their credentials

It's widely used for secure delegated access, such as allowing a user to log in to an app using their Google account or granting a photo editing app access to their Google Photos

OAuth 2.0 is the industry-standard protocol for authorization.


1. Resource Owner  - You
2. Client Application - Quora
3. Resource Server - Gmail / Google (contains the resources that are being accessed)
4. Authorization Server - Google OAuth Server


1. Client: Your Spring Boot application acting as a client to an OAuth2 provider. The application that is requesting access to the resource on behalf of the user.

2. Resource Owner: The user who grants access to their resources.  The user who owns the resource that is being accessed by the client.

3. Authorization Server: The server that authenticates the resource owner and issues access tokens. The server that issues access tokens to the client after successful authentication of the user.

4. Resource Server: The server that hosts the protected resources (your Spring Boot application when acting as a resource server). The server that holds the resource that is being accessed by the client.

5. Access Token: A credential representing the authorization granted by the resource owner.
6. JWT (JSON Web Token): A common format for access tokens in OAuth2.


==== OAuth 2.0 Flow ======

The OAuth 2.0 flow involves the following steps:

--> User requests access to a protected resource from a third-party application.
--> The third-party application redirects the user to an OAuth provider to obtain an access token.
--> The user logs in to the OAuth provider and grants permission to the third-party application to access the protected resource.
--> The OAuth provider issues an access token to the third-party application.
--> The third-party application uses the access token to access the protected resource on behalf of the user.



07.sb-security-oauth

Dependencies:  Spring Web,  Spring Boot Dev Tools, OAuth2 Client, Spring security

Create Welcome Rest Controller for /welcome


Google for "Google Cloud"	cloud.google.com	> Sign In >   Console		> 

Create or Select a New Project > New Project

> Select Project

Search for "API & Services"
	 	
> OAuth Consent Screen    User Type: External > Create	

App Information::	
Application: CTS	> ..... Save & Continue

> Create Credentials / Create OAuth client > OAuth2  > Create Credentials  - OAuth Client ID

Web App		Name: CTS App		URL: http://localhost:8080     Add Scopes:  email & profile
Redirect: http://localhost:8080/login/oauth2/code/google	> Create	Copy ID and Secret Key 




in application.properties
spring.security.oauth2.client.registration.google.client-id=<client_id>
spring.security.oauth2.client.registration.google.client-secret=<client_secret>



@Configuration
public class SecurityConfiguration {
	
 @Bean
 public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception{
   httpSecurity.authorizeHttpRequests(request -> request.anyRequest()												.authenticated());
   
   httpSecurity.oauth2Login(Customizer.withDefaults());  //Configures authentication support using an OAuth 2.0 and/or OpenID Connect 1.0Provider. 

   return httpSecurity.build();
 }





@RestController
public class WelcomeRestController {	
	@GetMapping("/")
	public String welcomeMessage(Authentication authentication) {
		System.out.println(authentication);
		System.out.println(authentication.getPrincipal());
		return "Hello World";
	}
}

--- Facebook
spring:
  application:
    name: spring-oauth2-security-example
security:
  oauth2:
    client:
      clientId: <client-id>
      clientSecret: <clientSecret>
      accessTokenUri: https://graph.facebook.com/oauth/access_token
      userAuthorizationUri: https://www.facebook.com/dialog/oauth
      tokenName: oauth_token
      authenticationScheme: query
      clientAuthenticationScheme: form
    resource:
      userInfoUri: https://graph.facebook.com/me


======================================================================================
JWT  jwt.io

-> JWT stands for JSON Web Token.

-> It is a token implementation which will be in the JSON format and designed to use for the web requests

-> JWT is most common and favorite token type that many systems use these days due to its features and advantages
Eg: while doing an online transfer of amount - OTP is required. We can consider OTP as a token

-> JWT Token can be used in both Authentication & Authorization scenario


JSON Web Tokens are an open, industry standard method for representing claims security between two parties. 
jwt.io allows you to decode, verify and generate JWT

JWT is the best secured way to communicate between the client and server and the advantages of using JWT is that it completely follows stateless authentication mechanism - it means all the user inputs or state is never saved in server memory or cookies.    
Why JWT? Traditional Approach

 

JWT contains username and  password in an encrypted manner with some other details

 
Sample JWT

A JWS - JSON Web Signature (the most common type of JWT) contains three parts separated by a dot ( . ). The first two parts (the "header" and "payload") are Base64-URL encoded JSON, and the third is a cryptographic signature

-> A JWT token has 3 parts which are separated by dot (.)
Sample JWT token

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

1) Header - represents header information which contains name of algorithm & type of token
2) Payload- claims information will be available here details)
   (registered claims / public claims / private claims)
3) Signature - encoded header + encoded payload + secret key

A JWT token signature is a cryptographic component that ensures the token's authenticity and integrity by verifying that it has not been tampered with and was generated by a trusted party. It is created by combining the Base64-URL-encoded header and payload, then signing the resulting string with a cryptographic algorithm and a secret or private key. The signature is then appended to the token


Decoded JWT
Header 
{
  "alg": "HS256",
  "typ": "JWT"
}
Refer: https://jwt.io/       https://jwt.io/introduction 
We can decode JWT Token using https://jwt.io/#debugger-io

alg – algorithm    typ – type of token    sub – subject    iat – Issued at

JWT Work Flow

Practical -> Spring Boot Application with JWT Token

-> In our spring boot application we have 2 endpoints 
    1) /hello	    2) /token

---> /hello endpoint is token based secured endpoint; if token is valid then only /hello endpoint will be executed

---> /token endpoint is used for getting JWT token based on user credentials.  If credentials are valid then only token will be generated 

Note : 
username: admin
password: admin@123

====================================================================
Reference: JWT Refresh Token in the Java Spring Boot Application.
	https://www.bezkoder.com/spring-boot-refresh-token-jwt/
	https://www.javacodegeeks.com/2024/12/managing-jwt-refresh-tokens-in-spring-security-a-complete-guide.html
====================================================================

New Project -> sb-security-jwt-app

Dependencies: Spring Web, Dev Tools, Spring Security, jjwt-api, jjwt-impl, jjwt-jackson, Lombok

Java JWT: JSON Web Token for Java and Android

JJWT aims to be the easiest to use and understand library for creating and verifying JSON Web Tokens (JWTs) and JSON Web Keys (JWKs) on the JVM and Android.

jjwt-api --> The public API for the JJWT library, used to create and consume JSON Web Tokens in Java
jjwt-impl --> Internal implementation module for JJWT, a Java library for creating and verifying JSON Web Tokens (JWTs)
jjwt-jackson --> to provide JSON serialization and deserialization support for the JJWT (Java JWT) library, enabling it to handle complex JSON Web Tokens by integrating with the Jackson library's ObjectMapper for data conversion



In Spring Security, the AuthenticationEntryPoint interface defines the contract for handling unauthenticated requests. Its primary role is to initiate the authentication process when a client attempts to access a protected resource without providing valid credentials or when their credentials are deemed insufficient.





logging.pattern.console= %green(%d{dd-MMM-yyyy HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%logger) %msg %n






https://www.bezkoder.com/websecurityconfigureradapter-deprecated-spring-boot/
https://www.codejava.net/frameworks/spring-boot/fix-websecurityconfigureradapter-deprecated
from boot 2.7.x

Reference: 
1) https://reflectoring.io/spring-security/
2) https://www.bezkoder.com/spring-boot-security-jwt/


@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http.authorizeRequests()
			.antMatchers("/home","/care")
			.permitAll()
			.antMatchers("/balance","/loan","/statement")
			.authenticated()
			.and().formLogin()
			.and().httpBasic();
		
		return http.build();
	}	
}



@Configuration
public class BasicSecurityConfiguration {
 @Bean
 public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {	
   http.authorizeHttpRequests(request -> request.requestMatchers("/home","/care").permitAll()
	.anyRequest().authenticated());
   http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
   http.csrf().disable();
   http.headers().frameOptions().sameOrigin();
   http.httpBasic();
   return http.build();
}


